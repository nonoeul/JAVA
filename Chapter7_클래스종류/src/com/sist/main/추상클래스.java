package com.sist.main;

import java.io.OutputStream;

/*
 * 	-----------	추상클래스(abstract)
 * 			 	=> 메소드 관련 (구현이 안된 메소드)
 * 				   ------------------------- 상속과 관련되어 있다. (오버라이딩) / 오버라이딩 기법을 사용하고 있다.
 * 	추상메서드는 설계만 되어 있고 구현할 수 없다.
 * 	추상메서드로 설계를 해놓으면 오버라이딩기법으로 쉽게 가져다가 쓸 수 있다. 	
 * 			오버라이딩
 * 
 * 			?추상 클래스를 왜 쓰냐 // 한 마디로 설계만 해놓을거를 상속을 받아서 오버라이딩을 통해 쉽게 기능을 변경해서 사용할 수 있게 만들어준다. 
 * 				=> 상속을 받아서 기존의 기능을 변경해서 사용하는 기법 
 * 				=> 조건
 * 			1) 상속관계 존재
 * 					=> 추상클래스는 단독으로 사용이 불가능하다.
 * 						=> 미완성된 클래스 / 사용을 할 수 없다. 
 * 					=> 사용법은 상속을 내린 후에 상속을 받을 클래스를 통해서 
 * 					   메모리 할당이 되는 상태이다. 
 * 						class A
 * 						class B entends A
 * 						=> A a=new B();
 * 						=> A a=new A(); // 오류 나는 코드이다. 자기 자신을 메모리 할당하지 못한다.
 * 				=> 구현이 된 클래스를 상속받아서 사용하는 것을 추상메서드라고 생각하면 된다.
 * 			2) 메소드명 동일
 * 			3) 리턴형 동일
 * 			4) 매개변수 동일 : 매개변수가 다른 경우 => 오버로딩 // 오버로딩은 다른 갯수, 다른 타입의 매개변수를 받아서 기존의 값을 변경해주는 것 , 오버라이딩은 같은 갯수, 같은 타입의 매개변수를 받아서 새로운 값을 할당해주는 것 
 * 		*** 기본 목적 : 여러 개의 클래스를 모아서 한 개 의 이름으로 제어 
 * 					  ------			 ------ // 여러 개를 한 개로 통합해서 사용 할 수 있게 만들어준다. 
 * 		*** 프로그램 설계 : (미완성된 클래스) 
 * 			= 요구사항 분석 
 * 			= 벤치마킹 : 여러개의 사이트를 참조 
 * 			예) 로그인 , 회원가입 , 예약 , 결제 등등 여러가지 사이트를 참조해서 기능을 만든다. 
 * 			= 프로그램에 맞게 구현해서 사용할 수 있게 해준다. 
 * 			예)
 * 				void btnClick();
 * 				{ 
 * 					계산기 1번 이동 
 * 				} 
 * 				=> 로그인 버튼 
 * 
 * 				void getConnection():
 * 				= 데이터베이스 연결
 * 				= 오라클/MS-SQL/MySQL/MariaDB..
 *			= 한 개의 객체로 여러개를 제어하는 프로그램 
 *			=  
 * 
 * 	추상클래스
 * 	=======
 * 		==> 공통적으로 사용하는 부분 (코딩 내용이 다르게 만들 경우)
 * 		예)
 * 			게시판 	: 목록출력, 찾기, 글쓰기, 내용보기, 수정하기, 삭제하기
 * 			묻고답하기	: 답변하기 + 목록출력, 찾기, 글쓰기, 내용보기, 수정하기, 삭제하기  	
 * 			댓글게시판	: 댓글 + 목록출력, 찾기, 글쓰기, 내용보기, 수정하기, 삭제하기
 * 			후기게시판	: 업로드 +목록출력, 찾기, 글쓰기, 내용보기, 수정하기, 삭제하기 
 * 	 	특정 한 기능만 추가하고 공통적으로 가지고 있는 기능을 추상클래스로 설정해서 갖다 쓸 수 있게 해준다.
 * 
 * 			abstract class Board 
 * 			{
 * 				목록출력(); 
 * 				찾기();
 * 				글쓰기();
 * 				내용보기();
 * 				수정하기(){};
 * 				삭제하기(){};
 * 				......
 * 				공통적인 기능들을 Board 안에 추상클래스로 묶어준다. 
 * 			}
 * 			** 권장사항 ==> 한 개 이상의 추상메소드를 포함한다.
 * 									------- 구현이 안된 메소드
 * 			(abstract) void find(); // 선언만된 것 구현이 불가능하다.
 * 			Board content(); // 구현이 가능하다. !! 
 * 
 * 		추상클래스의 특징 
 * 		1) 단일상속 => extends
 * 		2) 메소드가 구현이 안된것이 있으면 미완성 클래스이다. 
 * 			=> 메모리에 단독으로 저장이 불가능 
 * 			   abstract class A 
 * 			=> A a new=A ()
 * 		3) 상속을 내려서 구현된 클래스를 이용해서 메모리를 할당한다. 
 * 			=> abstract class A 
 * 			   class B extends A 
 * 			   ----------------- 구현이 안된 메소드를 구현한다. 
 * 			   => A a=new B(); // 묵시적 형변환 => 자동형변환과 동일하다
 * 				작은 클래스를 큰 클래스에다가 대입해주는 것을 의미한다. 
 * 				double d=10; // 자동형변환 
 * 
 * 			   => A a=new B();
 * 				  B b=(B)a; ===> 명시적 형변환 //
 * 
 * 				? 명시적 형변환 vs 묵시적 형변환?
 * 					묵시적 형변환 : 작은 클래스르 큰 클래스에다가 대입해주는 것은 큰 의미가 되지 않는다. 자동형변환 (묵시적 형변환)
 * 					명시적 형변환 : 큰 클래스를 작은 클래스에다가 대입을 해주게 된다면 큰 문제가 발생한다. 데이터가 짤려버린다. 
 * 					// 그래서 변수를 정의해줘서 잘릴 변수타입을 설정해주는 것이다. 
 * 		
 * 		4) 목적 : 관련된 여러 클래스를 묶어서 한 개의 이름으로 관리해준다. // 추상클래스가 해주는 역할이다.
 * 				 ------------- 
 * 				 => 공통적인 기능을 한다. 
 * 				 => 기능이 비슷하게 매우 많다. 버스, 마을버스, 고속버스처럼 비슷한 기능을 하고 있는 것들을 묶어주는 ㅓ것이다.
 * 				------------------------통합적으로 버스라고 한다. 버스 = 추상클래스 // 하나로 묶어버렸기 떄문에  
 * 				통합적인 한 개를 가지고 여러가지 기능을 수행할 수 있도록 만들어준다. 
 * 				 => 개, 돼지, 말 
 * 				========================> 동물 (추상클래스)가 된다. 
 * 			 	 => 선, 네모, 삼각형, 원 
 * 				========================> 도형 (추상클래스)가 있다. // 한 군데에다가 묶어주는 것, 추상클래스 
 */
abstract class 도형
{
	public abstract void draw();
	//무조권 구현해줘야한다.
	public void color() {
	// 필요에 따라서 오버라이딩을 해서 color 색상을 재정의할 수 있다
		System.out.println("검정색");
	}
}

class 선 extends 도형
{
	public void draw() {
		System.out.println("네모를 그린다.");
	}
}

class 세모 extends 선
{
	public void draw() {
		System.out.println("세모를 그린다.");
	}
}

class 원 extends 선
{
	public void draw() {
		System.out.println("원을 그린다.");
	}
}

/*
 *	1. 일반클래스 => new	// 사용자 정의로는 new와 인터페이스를 가장 많이 쓴다.
 *	2. 추상클래스 => 구현부 사용
 * 	3. 인터페이스 => 추상클래스와 동일 // 추상클래스보다는 인터페이스를 위주로 쓴ㄷ.
 * 		// 추상클래스를 알아두기만 하자. 상속을 많이 할 수록 속도가 느려져서 거의 사용안한다.
 * 	4. 종단클래스 => 상속해서 확장이 불가능
 * 	5. static  => 메모리 => 클래스명으로 접근한디. 
 */
abstract class A
{	
	public abstract void aaa();
	public abstract void bbb();
	public abstract void ccc();
	public abstract void ddd();
	public abstract void eee();
	public void fff() {} // abstract 추상 메서드를 받지 않았으므로 필수로 구현할 필요가 없다.
	public void ggg() {} 
	// 즉 강제성이 없다. 구현 할 필요가 없기 때문이다.~~ 
}
class B extends A
	// 추상메서드 5개가 선언되어 있어서 추상메서드 5개를 상속받으면
	// 상속받은 모든 추상메서드를 구현해야 한다.
{

	@Override
	public void aaa() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void bbb() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void ccc() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void ddd() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void eee() {
		// TODO Auto-generated method stub
		
	}
	// 무조권 구현해야한다. 선택적으로 구현할 순 없다. 강제성!! 무조권!! 
}


public class 추상클래스 {
	public static void main(String[] args) {
		
		도형 a=new 선();
		a.draw();
		
		a=new 원();
		a.draw();
		
		a=new 세모();
		a.draw();
		
		
		// stream이란 외부에서 데이터를 읽거나 외부로 데이터를 출력하는 작업을 할때 나타나는 통로 stream
		// InputStream, OutputStream은 둘 다 추상 클래스이며 추상 메소드를 오버라이딩 해서 써야한다.
		// 다양한 역할을 수행할 수 있다. 
	}
}











































