/*
 * 
 * 	메모리구조 3단계
 * 	(1) MethodArea , static => 컴파일러가 자동 저장 
 * 		Method도 메모리에 저장된다. 
 * 		void method();
 * 		{
 * 		}
 * 		메소드는 구현부가 있을때만 저장이 된다. 
 * 	=>	메소드가 선언만 되어 있는 경우에는 클래스를 저장하지 못한다.(미완성된 클래스) 
 * 		(추상클래스, 인터페이스) => 요구사항 분석할때 사용된다.  	
 * 		void method(); 
 * 
 * 	(2) Stack : LIFO
 * 				지역변수, 매개변수가 저장된다. => 메모리 자체에서 관리 {} 블럭이 종료되면 사라진다.
 * 				class A
 * 				{
 * 					변수값1
 * 					void method()
 * 					{
 * 						변수값2
 * 						if()
 * 							{
 * 							변수값3
 * 							}
 * 					}
 * 				}
 * 		변수값 3 -> 변수 2 -> 변수값1 순서로 사라진다. 늦게 선언만 변수가 
 * 		제일 먼저 구현된 후 사라진다. 
 * 	--------------------------
 * 	Heap : 동적메모리 할당(new) => 객체변수, 배열(참조변수값)
 * 			=> 관리(프로그래머) => GC(자동메모리 회수)
 * 			=> 객체 = null값 
 * 	A,java ==> A.class ==>
 * 		javac		   java 
 * 	class A => 인터프리터 => 한줄씩 번역해 나가는 것 
 * 	{
 * 		---
 * 		---
 * 		---new
 * 		---
 * 		?동적메모리할당이란 메소드 전체를 메모리에 할당해주는 것이 아니라
 * 		식을 진행시키다가 new를 만나면 new부분만 객체를 생성해서 메모리에
 * 		할당해주는 것을 의미한다. 
 * 	}
 * 	--------------------------
 * 	변수 => Stack에 저장 
 * 			int a= 10; 일때
 * 
 * 		0------
 * 			사용중
 * 		4------
 * 			사용중
 * 		8------
 * 			값 => 10 // 값이 10이 들어간다. ==> 메모리 주소에 대한 별칭 a
 * 			맨 마지막으로 할당한 값이 저장된다.
 * 
 * ? 베얄 vs 클래스
 * 	배열 : 	배열의 메모리구조는 병렬로 되어 있디.
 * 			모든 데이터의 데이터값이 일정한다.
 * 			|a|b|c|
 * 		
 * 	클래스:	클래스는 메모리구조가 직렬로 되어 있다.
 * 			서로 다른 값을 할당해서 묶어줄 수 ㅇㅆ다.
 * 			------------------
 * 				  홍길동
 * 			------------------
 * 					A
 * 			------------------
 * 				   200
 * 			------------------
 * 
 * 	-----
 * 	1. 구성요소
 * 		1) 변수
 * 			= 인스턴스 변수 : 객체마다 메모리 따로 저장
 * 						   => new를 이용해서 메모리 저장공간을 만들어진 경우 
 * 			A a=new A()
 * 					인스턴스 (객체)
 * 					a.변수명 
 * 			= 정적 변수 : 메모리 공간이 한 개를 사용한다.(공유변수,클래스변수)
 * 				-static    => 컴파일시 자동으로 생성되는 공간이다. 
 * 				클래스명.변수명 
 * 			메소드 호출시에 생성---------------------------------------------
 * 			= 지역변수	 : 기능 처리에 필요한 데이터를 설정 / 메소드종료와 동시에 사라진다.
 * 			= 매개변수	 : 사용자의 요청값 | 메소드종료와 동시에 사라진다. 메소드 내에서만 유효하다. 
 * 			--- 변수는 반드시 초기화 후에 사용한다. ---
 * 						  --------- 자동 초기화 : 클래스영역에 선언되는 경우 / 인스턴스, 정적변수는 초기화가 된다.
 * 						  			초기화가 없는 경우 : 지역변수, 매개변수 
 * 		   class A
 * 			{
 * 				String addr;
 * 				void Address(String addr)
 * 				{
 * 					this.addr=addr
 * 					지도출력(addr)
 * 				}
 * 				void 지도출력()
 * 				{
 * 					addr
 * 				}
 * 			}
 * 
 * 		2) 메소드:	명령문의 집합이다 => 단락을 나눠줌(구조적 프로그램) 
 * 					반복수행(제거) => 재사용 (한가지 기능 수행)
 * 			1. 종류
 * 				인스턴스 메소드 : 따로 작동하는 메소드  
 * 					String s="Hello Java";
 * 					s.substring()
 * 					String s1="Hello Oracle";
 * 					s1.substring()
 *
 * 
 * 				정적메소드 : 동시에 작동할때 (static => 자동으로 저장이 될떄)
 * 					10=>"10" , true=>"true", 문자열로 바꾸고 싶다.
 * 					String.valueOf(데이터형) // 
 * 			1. 제어하는 대상이 없으면 static이다.
 * 				String.valueof(데이터형]
 * 				Math.random // 값을 바꿀 필요가 없다. 고정적인 함수이다. 
 * 			2. 한번에 제어를 해야할때 한번에 바꿔야 할때					
 * 				넓이, 높이, 간격 같이 한 번에 제어할떄 static					
 *  
 * 				추상메소드 : 설계 => 모든 개발자가 같은 메소드를 제어할때 
 * 							  => 표준화 작업
 * 							  => 여러개의 클래스를 묶어서 한 개의 이름으로 제어 
 * 				설계만 내놓는 것, 언제든지 갖다가 쓸 수 있다.
 * 				기능은 구현이 안된 상태, 설계만 된 상태이다. 
 * 
 *				종단메소드	: final void aaa() => 변경할 수 없는 메소드(확장없음)
 * 				=> 수정 변깅이 불가능한, 확정적인 메소드 값을 할당할때 사용된다.
 * 
 * 		3) 생성자
 * 			= 객체 생성시 호출되는 메소드
 * 			= 멤버변수의 초기화 
 * 			= 클래스명과 동일 
 * 			= 리턴형이 없다. 
 * 			= 생성자는 여러 개가 존재할 수 있다. 한개만 존재하지 않는다,
 * 			= 생성자를 여러 개 생성 // 같은 이름을 가지고 여러 개 생성 (오버로딩)
 * 			= 클래스 안에 생성자를 반드시 구현하는 것은 아니다
 * 				=> 클래스 안에 생성자가 없을 경우 기본생성자를 한 개를 만들어준다. 
 * 				=> 기본생성자는 매개변수가 없는 생성자를 의미한다. 
 * 				=> 생성자는 필요하면 쓰면 돼고, 필요없으면 안쓰면 됀다. 
 * 		= 변수만 모아서 관리	  // 사용자 정의 데이터형 (~vo,~DTO,~Bean) 데이터만 모아 놓은 것 [Music] 
 * 			getter/setter은 메소드인데 메소드라고 생각하지 않는다.
 * 			변수의 기능만 가지고 갈 수 있게 해주는 것이다. (읽기 / 쓰기)
 * 
 * 		= 메소드만 모아서 관리  // 액션 클래스 
 * 			~System, ~DAO, ~Manager, ~Service.. 모두 기능만 가지고 있다 
 * 			액션 클래스를 통해 기능만 가지고 있다고 인식하면 됀다.
 * 		
 * 		= 변수+메소드 : 조립  
 * 			~Model, ~Controller, ~Action 							
 * 
 * 	2. 클래스 설계
 * 		(1) 기능 설계 : 메소드 추출하는게 가장 먼저이다. 어떤 메소드를 가지고 있는지에 대해서 
 * 		(2) 기능에서 사용하는 변수 추출
 * 		(3) 클래스 설계
 * 			= clas ClassName
 * 				{
 * 				변수		int x ,stirng y ... 처럼 어떤 변수를 지정해줄 건지
 * 				메소드	어떤 형태의 메소드를 만들고 매개변수를 줄 지 안줄지
 * 				생성자	생성자를 생성
 * 				}
 * 		(4) 메모리 저장
 * 			ClassName c=new ClassName()
* 		(5) 활용
* 			c.메소드
* 		(6) 소멸
* 			c=null
* 	3. 접근지정어
 * 		-----------------------------
 * 		private : 자신의 클래스에서만 사용이 가능하다 => 데이터보호(캡슐화)
 * 				  private의 보호성을 가지면서 입력값을 활용하는 방법으로 getter/setter이 있다.
 * 		-----------------------------
 * 		default : 같은 패키지내에서만 접근이 가능하다.
 * 		-----------------------------
 * 		protected : 같은 패키지안에서만 접근이 가능하다, 단 상속이 있는 경우 다른 패키지에서 접근이 가능하다.
 * 		-----------------------------
 * 		public : 패키지 상관없이 모든 클래스에서 사용이 가능하다
 * 		-----------------------------
 * 		멤버변수 [접근지정어] 데이터형 변수명 // 변수를 쓸 수 있는 부분을 할당해준 것 
 * 		메소드 [접근지정어][제어어] 리턴형 메소드명(매개변수목록)
 * 			{		   ----- static, abstarct, final 제어엉 종류 
 * 
 * 			}
 * 		=> 변수 	: private 
 * 		   메소드	: public
 * 		   셍성자	: public 
 * 
 * 	4. 객체지향의 특성
 * 		1) 캡슐화 과정이 있다. => 데이터를 은닉화한다. 
 * 		   메소드를 통해서만 접근할 수 있게 해준다.
 * 			=> 데이터를 보호하고 , 사용자가 볼 필요가 없는 정보를 숨긴다.
 * 			=> private ==> getter/setter 
 * 		2) 재사용기법 
 * 			=> 상속 (is-a)	: 기존에 기능을 변경해서 사용. // 상속클래스
 * 			class A
 * 			{
 * 			}
 * 			class B extends A => 단일상속
 * 			{
 * 			}
 * 		  	
 * 			=> 포함 (has-a)	: 기존의 기능을 있는 그대로 사용한다. // 포함클래스
 * 			class A
 * 			{
 * 			}
 * 			class B
 * 			{
 * 				A a;
 * 			}
 * 							
 * 		3) 수정, 추가 => 다형성
 * 			오버라이딩
 * 			------------------------
 * 			메소드명 동일
 * 			------------------------
 * 			상속관계 한 개 클래스 // 상속 관계
 * 			------------------------
 * 			매개변수 동일 // 매개변수의 갯수/데이터형
 * 			------------------------
 * 			리턴형 동일 // 리턴형은 관계 없다.
 * 			------------------------
 * 			접근지정어 확장
 * 				기능수정 / 새로운 기능 추가 
 * 			------------------------
 * 
 * 	5. 제어자 
 * 		static / abstract / final 정도가 제어자라고 볼 수 있다. 
 * 		=> static / final : 상수
 * 		=> final : 상수형 변수 ==> final만 메소드안에서 사용이 가능하다. 
 * 			=> final은 사용하는 위치가 변경되지 않은 위치이다.
 * 			=> final변경되지 않기 때문에 메소드안에서 사용해도 무방하다. 고정시켜노흔다.
 * 		=> 제어자는 위치를 사용하는 위치를 설정해놓는 것이다.
 * 
 */
public class 객체지향정리_1 {
	public static void main(String[] args) {
		
	}
}






































