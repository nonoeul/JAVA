package com_sist_exception;
/*
 * 
 *	final클래스 => 종단 클래스 (java.lang)
 *	--------------------- 확장할 수 없다. (있는 그대로 사용) => 상속을 내릴 수 없다
 *				fianl은 상위클래스 부모클래스가 될 수 없다. 그냥 클래스에서만 사용해야 한다.
 *
 *	java.lang
 *	java.util
 *	java.io
 *	java.net 
 *	java.text 
 *	---------- 자바의 기본 라이브러리이다.	
 * 	java.sql , javax.http.servlet.* javax.xml
 * 
 * 	4. 오버라이딩 (상속의 기본) => 변경해서 사용 (다형성)
 * 	
 * 	==??객체지향의 3대 요소=== // 객체지향의 목적  
 * 		1. 데이터 보호 목적
 * 			-캡슐화 : 변수를 은닉화를 시켜주는 것, 메소드를 통해서 접근이 가능하게 하는 것
 * 					1. 은닉화는 private을 쓴다음 getter/setter을 사용하는 것 
 * 					2. 접근이 가능하게 하는 것은 public
 * 					== 변수는 2가지 기능만을 수행하는데, 메모리저장 / 메모리에서 데이터 읽기 
 * 					   메모리저장(setter) / 데이터읽기(getter)
 * 					=> 모든 멤버변수는 private으로 감춰주는게 좋다. // getter/setter
 * 					=> 모든 메소드(생성자) : public => 다른 크래스와 연결이 가능하게 만들어 준다. 
 * 			접근 지정어
 * 			--------
 * 			1)private = 자신의 클래스에서만 사용이 가능 / 다른 클래스. 다른패키지에서 사용 불가
 * 			2)default = 자신의 클래스와 패키지에서만 사용 가능 / 다른 패키지에서 사용 불가
 * 			3)public  = (공개) 모든 클래스와 패키지에서 사용 가능 
 * 			4)protected = 자신의 클래스와 패키지에서만 사용 가능 / 단 상속시 다른 패키지에서 사용 가능 
 * 		2. 재사용할 목적 
 * 			상속, 포함, 목적
 * 			class A
 * 			class B extends A => A가 가지고 있는 모든 내용을 가지고 온다.
 * 					------- A의 내용을 변경해서 사용 , 추가 가능
 * 			== 상속받은 후에 A의 데이터를 가지고와 A의 내용을 사용, 추가가 가능하다 .
 * 			== 라이브러리 => 프로그램에 맞지 않는 경우 (수정)
 * 			== 상속을 내린 클래스 > 상속을 받은 클래스 // 상속을 내린 클래스가 더 크다 .
 * 			 	=> A a=new A()
 * 			 	=> B b=new B()
 * 			 	=> A c=new B() 	= 묵시적 형변환(자동)
 * 				--------------> 추상클래스 / 인터페이스 (메모리할당이 안된다)
 * 								-----------------
 * 								메모리 할당시에 상속을 받은 클래스를 이용해서 메모리 할당을 한다.
 * 								미완성 클래스(아무것도 없지만 클래스이다.) // 메소드가 구현이 안된 상태
 * 					추상클래스는 구현이 안된 상태이기 떄문에 메모리에 할당이 안되 있따. 그러기 떄문에 추상클래스/인터페이스의
 * 					추상메서드가 존재한다면 전부 다 구현을 시켜줘야 한다. 그렇지 않ㅇ면 오류가 발생한다.
 * 					=> 인터페이스, 추상메서드는 설계, 같은 기능을 처리할 떄 프로그램에 형태에 맞게 사용한다.
 * 						=> 버튼,클릭 같이 내용은 비슷한데 처리하는 내용ㅇㄴ 다를 때 인터페이스를 이용한다. 
 * 
 * 			 	=> B d=B(c); 	= 명시적 형변환(강제)
 * 				------------ 라이브러리에서 많이 사용
 * 				=> 클래스를 저장해서 관리 (클래스) = collection 
 * 				'A' 'BBBBB'
 * 				1byte 5byte 
 * 				'A' 'BBBBB' ==> 100byte
 * 				들어가는 변수의 비트마다 가변적으로 바뀌는 것 	= Arraylist
 * 				변수의 데이터양을 정하고 변수의 데이터를 넣는것	= 배열
 *  
 *  	
 * 			class A
 * 			{
 * 				B b=new B(); // 특별한 경우가 아니면 재정의하지 않는다.
 * 			}
 * 
 * 
 * 		3. 수정, 추가 목적 (유지보수)		
 *  		수정(오버라이딩) 추가(오버로딩)
 *  
 *  ??오버로딩 vs오버라이딩 차이??
 *  
 *	 			오버로딩			오버라이딩
 *	====================================
 * 	관계			한개의 클래스 		상속관계
 * 				상속관계
 * 	====================================
 * 	메소드명		동일				동일
 * 	====================================
 * 	매개변수		갯수나			동일
 * 				데이터형이 다르다.
 * 	====================================
 * 	리턴형		관계없음			동일
 * 	====================================
 * 	접근지정어		관계없음			확장가능
 * 	====================================
 * 	사용처		생성자			인터페이스/추상클래스
 * 	====================================
 * 		*** 상속
 * 		1) 호출		=> 상위클래스의 생성자가 먼저 호출 (기본생성자)
 * 			class A
 * 			{
 * 				public A(int a){}
 * 			}
 * 			class B extends A
 * 			{
 * 				public B(int a,int b){}
 * 			}
 * 			B b=new B();
 * 				=> new A() => new B()
 * 
 * 
 * 		2) 예외조건 : static , 생성자 , 초기화블럭 ,
 * 
 * 		class A
 * 		class B extends class A
 * 		class C extends class B
 * 		class D extends class C
 * 		-----------------------
 *		A a=new A() 
 *		A a=new B() 
 *		B b=new B() 
 *		B b=new D() 
 *		B b=new E() 
 * 		------------
 * 		B b=(B) a
 * 		상위 클래스의 매개변수 a를 하위 클래스 b에다가 대입할 때
 * 		큰 것을 작은 것에 대입하므로 명시적 형변환을 해줘야만 한다.
 * 		
 */
import java.util.*;

class A
{
	int a=10;
	String name="홍길동";
	public A(){} // 메모리 할당이 안되있어서 그렇다. 
	public A(int a)
	{
		this.a=a;
	}
}
/*
 *	class A에 public A(int a) // int a를 매개변수로 가지고 있다.
 *	public A(int a) 매개변수로 가지고 있으므로 자동으로 생성자를 만들어주지 않는다.
 *	매개변수를 가지고 있는 매개변수는 자동으로 생성자를 만들어주지 않으므로 생성자를 만들어줘야한다. public A(){}
 *	만약 class A에 public A(){} 생성자가 없다면 
 *	아래 class B extends A가 오류를 발생한다.
 */
	//new A() ==> 매개변수가 있는 메소드는 자동으로 생성자를 호출 해 줄 없다.
/*
 * 	?? 클래스의 종류??
 * 		=추상클래스
 * 		=인터페이스 => 추상클래스의 단점을 보안 (클래스와 동일하게 취급)
 * 			=> 클래스(단일) / 인터페이스(다중)
 * 		--- 설계도(구현이 안된 상태) --- => 미완성 클래스 
 * 		클래스와 인터페이스 둘다 미완성 클래스라고 하고 메모리 할당을 할 수 없다.
 * 		자신이 메모리 할당을 할 수 없어 직접 사용할 수 가 없다. 
 * 		여러 개의 관련된 클래스를 모아서 한 개의 객체명으로 제어 // 추상클래스 / 인터페이스이다. 
 * 		-------------------------------------------------------------------
 * 					추상클래스			인터페이스 
 * 		========================================
 * 		상속관계		단일상속			다중상속
 * 		========================================
 * 		상속키워드		extends			implements
 * 		========================================
 * 		멤버변수		인스턴스변수		인스턴스, 정적변수 사용 할 수 없다.
 * 					정적변수			상수형 변수만을 사용할 수 있다. ** 중요포인ㅌ
 * 					둘 다 사용 가능 	// 생성자가 없다. 인스턴스, 정적변수를 가지고 있지 않기 때문에
 * 		========================================
 * 		메소드		구현된 메소드		구현이 안된 메소드 
 * 					구현이 안된 메소드
 * 		========================================
 * 		기법 			오버라이딩 		오버라이딩 
 * 		========================================
 * 		
 * 		??? 추상클래스 형식 ???
 * 		형식
 * 			추상클래스
 * 			[접근지정어] abstract class ClassName
 * 			{
 * 				------------------------------
 * 				변수
 * 					인스턴스 변수
 * 					static 변수
 * 				------------------------------
 * 				메소드
 * 					구현된 메소드
 * 					[접근지정어] 리턴형 메소드명 (매개변수...)
 * 					{
 * 						블록을 열고 닫고하면 구현이 된다.
 * 					}
 * 					구현이 안된 메소드(선언)
 * 					메소드를 선언을 할 때는 [접근지정어] abstract 리턴형 메소드명(매개변수); 으로 선언을 한다.
 * 						구현이 안된 메소드를 선언할때는 무조권 abstract를 붙어야 한다. 
 *   			------------------------------
 * 				생성자 , 오버로딩이 가능하다. 			
 * 				------------------------------
 * 			}	** 추상클래스는 인스턴스 변수와 정적변수를 가질 수 있기 떄문에 매개변수에 
 * 					인스턴스 변수나 정적변수를 가지고 있다면 생성자를 만들어줘야 한다.
 * 				추상클래스 == 생성자O					
 * 
 * 				** 인터페이스같은 경우는 인스턴스변수나 정적변수를 가지지 못하고 상수만을 가질 수 잇으므로
 * 					매개변수로써 인스턴스변수나 정적변수를 가지고 있찌 않기 때문에 생성자를 만들지 않아도 됀다.
 * 				인터페이스 == 생성자X
 * 		========================================	
 * 	
 * 		?? 인터페이스 형식??
 * 		[접근지정어] interface Interface명{
 * 			--------------------------
 * 			변수선언 (상수형 변수)
 * 				int a=10; => 값을 명시적으로 지정
 * 				=> public static final int a=10;
 * 			변수선언 상수형 변수 , 값을 명시적으로 지정 
 * 
 * 			--------------------------
 * 			구현이 안된 메소드 목록
 * 			void display();
 * 				=> public abstract void display();
 * 			앞에 public abstract가 생략이 되어 잇는 것이다.
 * 			public abstract가 생략이 되어 있다. 
 * 
 * 			---------------------------
 * 			구현한 메소드 목록 
 * 			default void aaa(){}
 * 				=> public default void aaa(){}
 * 			static void bbb(){}
 * 				=> public static void bbb(){}
 * 
 * 			=> 인터페이스 변수는 메소드가 public => 언제든지 public
 * 		인터페이스는 연결목적이다. 기능들을 이어주는 역활로써 default, private처럼 
 * 		보안이 되어있다면 인터페이스를 갖다가 쓸 수 가 없다. 
 * 		==========================================================
 * 
 * 		상속
 * 				extends
 * 		interface ==> interface // 인터페이스에서 인터페이스로 갈 떄는 extends로 확장해주고
 * 				implements
 * 		interfcae ==> class	// 인터페이스에서 클래스로 갈 때는 implement로 이어준다.
 * 
 * 		다중상속
 * 		class A implements 인터페이스,인터페이스 ... 
 * 
 * 
 * 
 */

class B extends A
{
	int b=20; 
	public B()
	{
		
	}
}

public class 정리7장 {
	public static void main(String[] args) {
		// 오브젝트 Object 최상의 객체를 할당 받았으므로 
		// Object 값에는 문자열, 문자, 정수, 클래스까지 전부 다 들어갈 수 있다.
//		List list=new ArrayList();
//		list.add("");
//		list.add(1);
//		list.add(new 정리7장());
	
		A a=new B();
		B b=(B)a;
		
		
	}
	
}



























