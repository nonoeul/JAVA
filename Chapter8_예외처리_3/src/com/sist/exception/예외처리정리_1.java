package com.sist.exception;
/*
 * 	??예외방법과 형식??
 *		= 직접처리(예외복구) : 프로그래머
*			try
*			{
*				실행 가능한 소스 코딩 (정상수행이 가능한 코드)
*				try안에는 정상수행 할 수 있는 것을 넣어주면 됀다. 
*			}catch(예외처리종류)
*			{
*				try안에 있는 소스를 실행하는 과정에서 에러가 발생시 처리영역
*				try를 대신해서 수행하는 문장이다
*			}
*			finally // 생략이 가능하다. 
*			{
*				생략이 가능하다 : 무조권 수행한다 (try,catch)
*				서버 닫기, 오라클 닫기, 파일 닫기 
*			}
*		  catch는 에러발생시 예외를 복구하는 영역이기 때문에 
*		  -----catch같은 경우는 다중으로 사용이 가능하다(여러개를 구현할 수 있다.)
*		  1. catch는 다중으로 왔을 때 한 개의 예외를 통합으로 사용ㅇ 가능하다 .
*		  2. 한 개의 예외로 통합해서 사용할 떄 쓰는 것이 Throwable/Exception이다. 상위객체			
*		  3. try-catch절은 에러가 난 곳부터 수행하지 않는다.
*			=> try절에는 에러 발생시에는 에러 난 곳부터 수행하지 않는다.
*			=> catch를 수행해서 에러 복구 => 종료
*		   	즉 오류가 난 곳부터 아래에 있는 것들은 수행되지 않는다. 		
*		  4. catch는 위에서부터 검색을 한 뒤에 해당 예외처리클래스를 찾아준다. 
*		  5. 다중조건문과 동일하다 (catch는 한개만 실행된다.) 동시에 여러개가 실행되지안흔ㄷ.
*
 *	 ??간접처리(예외회피)?? : 자바나 오픈API(라이브러리)에서 사용
 *		  예외에 대해서 예측되는 예외클래스르 선언만 한다.
 *		 1. 다른 메소드에서 호출시에 처리한 뒤에 사용 가능하다. (try-catch)
 *		 2, 예외클래스의 순서가 존재하지 않는다. 순서가 존재하지 않기 때문에 쓰고 싶은대로 쓴다. 
 *		 3. UncheckException은 사용하지 않고 보통 CheckException만을 사용한다 .
 *		  	=> RuntimeException,
 * 		 4. 라이브러리 
 * 			java.lang / java.util => UnCheckException
 * 			 => 반드시 예외처리를 해야하는 것은 아니다.
 * 
 * 			java.io / java.net / java.squl => CheckExcption 
 			 => 예외처리를 반드시 한다.
 			 
 			형식)
 			  [접근지정어] 리턴타입 메소드명() throws 예외처리클래스..... 
 			  => 처리
 			  메소드() throws 예외처리클래스 {
 			  
 			  }
 			  
 			====================================
 			  메소드()
 			  {
 			  	try
 			  	{
 			  		메소드호출 
 			  	}catch(예외처리 클래스){}
 			== try/catch가 default값 권장사항이다. 
 			  	
 *		------------------------------------
 *		??임의발생?? 
 *		임의발생의 목적: 테스트용으로 보통 사용된다. 
 			throw new 예외처리클래스() => 해당 예외처리클래스가 이는 catch로 이동
 			
 			
 		??사용자 정의 예외처리??
 		예외처리 클래스를 상속 받아서 처리 
 		class MyException extends Exception
 				-----------------------------> if~else 
  		계층 구조를 자주 보자 
 
 * 
 * 
 */
public class 예외처리정리_1 {

}













