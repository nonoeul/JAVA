package exam;
/*
 * 	6장 시작
 * 	=> 재사용 기법을 사용해야 하고
 * 	=> 수정, 추가를 할 줄 알아야 하고
 * 	=> 클래스의 종류를 알아야한다. 
 * 	----견고한 프로그램을 만들 수 있다.!!
 * 	??견고한 프로그램이란
 * 	1. 재사용이 가능해야한다.	// 재사용이 불가능하면 쓰레기코드
 * 		=> 상속, 포함
 * 	2. 가독성이 좋아야 한다.	// 다른 사람이 가독 가능
 * 		=> 메소드
 * 	3. 견고성
 * 		=> 예외처리	
 * 	4. 나머지는 전부 라이브러리이다. 갖다쓰면 돼지요! 
 * 	------------------------------------- 
 *		자바 상속의 특징 
 *		= 재사용 목적으로 사용한다 (기존의 만들어진 클래스를 확장해서 사용)
 *			*** 필요시에는 변경해서 사용이 가능하다 (오버라이딩)
 *		= 반복 코딩을 제거할 수 있다. 
 *			class A
 *			{
 *				int a,b,c,d,e;
 *				void display(){}
 *				--
 *				--
 *				--
 *			}
 *			class B extends A
 *			{
 *				void display(){}
 *			} 
 * 			= 기존에 만들어진 클래스를 확장해서 새로운 클래스를 만들어서 사용 
 * 			  예)
 * 				class 게시판 
 * 				{
 * 					여러 기능들을 사용 
 * 				}
 * 
 * 			// 확장 => 기존 기능을 사용, 변경, 추가할 수 있다. 
 * 			class 갤러리게시판 extends 게시판
 * 			{
 * 				// 게시판을 상속받아서 갤러리게시판을 만들어 준다.
 * 				class 게시판의 여러 기능들
 * 				+
 * 				내가 추가하고 싶은 기능 
 * 				// 기능을 가져와 필요한 기능을 추가,변경 가능 
 * 			}
 * 		
 * 		= 유지보수용 (SM)
 * 		// 기존에 있는 것에 기능을 추가하거나 변경할때 많이 쓰인다.
 * 		// 단일 상속만 가능하다. 
 * 		//	class A
 * 		  	class B extends A
 * 		  	class C extends B
 * 		  = 상속을 내리는 클래스	: 부모클래스, 슈퍼클래스, 베이스클래스
 * 							  상위 클래스 
 * 
 * 		  = 상속을 받는 클래스	: 자식클래스, 서브클래스, 파생클래스 
 * 							  하위 클래스
 *			
 *		  = 상속이 있는 경우 클래스의 크기가 있다. (형변환) 형변환이 가능하다. 
 *
 * 		  = 상속을 내리는 클래스 => 상속을 받는 클래스보다 크다. 
 * 			----------------------------------------
 * 			동물 / 인간 
 * 			
 * 			class Super
 * 			class Sub extends Super // Super클래스가 더 크다.
 * 			----------------------------------------
 * 			Sub sub=new Sub();		// 확장된 클래스 자체
 * 			Super super=new Sub();	// 하위 클래스를 이용해서 상위 클래스 생성
 * 			---------------------------------------- 인터페이스 / 추상클래스 
 *		    Sub sub1=(Sub)super; // 형변환후 사용
 *			---------------------------------------- 
 *
 *			일반적으로 
 *			클래스 = 생성자 동일 
 * 			---------------------------------------- 
 * 			=> 클래스와 생성자가 다른 경우
 * 			=> 클래스와 메소드 이용 
 * 			----------------------------------------  인터페이스 
 * 			인터페이스 본인이 접근할 수 없다. new를 통해서 접근해야 한다.
 * 			인터페이스 자체가 new를 사용하지 못한다. 객체 자체를 선언만 가능하지
 * 			객체 자체를 생성할 순 없다. 
 * 		
 *	==> class A
 * 		{
 * 			int a,b;
 * 			void display(){1}		
 * 		}
 * 			
 * 		class B extends A
 * 		{
 * 			// int a,b
 * 			int c;
 * 			void display(){2}
 * 		}
 * 
 * 		A aa=new A();
 * 		aa.a
 * 		aa.b
 * 		aa.display() ==> 1
 * 
 * 		B bb=new B();
 * 		bb.a , 
 * 		bb.b , 
 * 		bb.c 를 갖다 쓸 수 있다. 	
 * 		
 * 		A aaa=new B();
 * 		aaa.a 
 * 		aaa.b 
 * 		aaa.c 
 */

class Super
{
	int a=10;
	int b=20;
	public void display()
	{
		System.out.println("Super가 가지고 있는 display...");
	}
}

//Super클래스를 상속받는다 Super(부모) / sub(자손)
class Sub extends Super 
{
/*	 안에는 Super의 내용을 모두 가지고 있다. Super와 동일한 내용이 출력된다.
	 이런 상속된 값을 변경을 하는 것을 오버라이딩이라고 한다. 
	Super로부터 상속을 받는다 => 예외조건) 생성자, 초기화 블록, static(공유)
	private => 상속은 가능한대 접근이 불가능하다.
	1. private는 상속을 하더라도 접근이 불가능하므로 protected를 권장한다
	2. pritvate 상속 하더라도 접근이 불가능하므로 getter/setter을 사용한다. 
	== proteceted & getter/setter을 사용한다. 이 두개를 사용 ~!! 
*/
}

public class 상속_6장_정리_이론 {
	public static void main(String[] args) {
		Sub sub =new Sub();
		System.out.println(sub.a);
		System.out.println(sub.b);
		sub.display();
		
		
		
	}
}
















































