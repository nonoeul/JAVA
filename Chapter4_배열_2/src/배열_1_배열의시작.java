import java.util.Arrays;

/*
 * 
 * 	***모아서 관리
 * 	= 데이터 => 배열 / 클래스(****)
 * 	= 명령문 => 메소드 (재사용)
 * 	1. 같은 데이터형 모아서 관리
 * 	-------------
 * 		= 연속적으로 메모리 배치
 * 		= 인덱스번호를 이용한다 (0부터 시작)
 * 		= 고정적이다 (변경시에는 더 큰 배열을 생성해서 사용한다)
 * 		=배열 복사
 * 		=얇은 복사 => 별칭, 참조 (같은 메모리 주소를 활용)
 * 		=깊은 복사 => 데이터만 복사, 새로운 메모리를 만들어서 저장
 * 			int[] arr{};
 * 			int[] arr{};
 *		=깊은 복사 => 데이터만 복사, 새로운 메모리를 만들어서 저장 
 * 			int[] arr={};
 *			int[] arr2=arr.clone() 
 * 			System.arraycopy
 * 		= 배열의 크기 : length
 * 		= 출력시에는 주로 사용 => for-each(향상된for문)
 * 		----------------------------브라우저에서 변경하는 것이 아니라 있는 그대로 출력
 * 		배열 / 컬렉션 (데이터가 모아있어야 사용이 가능)
 * 		=> 인덱스를 이용하는 프로그램이 아니다.
 * 		=> 배열에 저장된 값을 한개씩 읽어본다.
 * 		int[] arr={10,20,30,40,50}
 *		-------------------------------------------------- 	
 * 		for(int a:arr)
 * 		{
 * 			a=10 , a=20, a=30, a=40, a=50 ==> 종료를 자동 처리
 * 		}
 * 		
 * 		char[] arr={'A','B','C'}
 * 		for(char c:arr)
 * 		{ -----크거나 같아야 한다.
 * 			// char c는 실제 저장된 데이터를 가지고 있다.
 * 		}
 * 		= 초기값, 값을 변경시에는 일반 for문을 이용한다.
 * 		--------------------------------------------------
 * 
 * 		int[] arr={10,20,30,40,50};
 * 		
 * 		for(int i=10:arr)
 * 		{
 * 			i=100;
 * 		}
 * 		값을 변경할 수 없다. 변경하려면 index값을 변경해야한다.
 * 		값을 변경하기 위해서는 인덱스 변수가 필요
 * 		이미 i에다가 10을 받았는데 i=100을 또 다시 부여했다.
 * 		값이 변하지 않는다. 
 */

public class 배열_1_배열의시작 {
		public static void main(String[] args) {
			int[] arr= {10,20,30,40,50};
			for (int i:arr) 
			{
				i=100;
				System.out.println("i="+i);
			}
			// i의 배열을 배정해도 i=100으로 할당해버리면 전부 다 100이 나온다.
			System.out.println(Arrays.toString(arr)); // 배열은 바꾸지 않았다.
			// 출력용으로 바구지만 원본은 바꾸지지 않는다.
			// arr[0] , arr[1] 실제 변수명을 변경해야한다. 
			
			/*
			 * 		i=arr[0]
			 * 		i=arr[1]
			 * 		i=arr[2]
			 * 		i=arr[3]
			 * 		i=arr[4] 
			 * 
			 * 		int i=10;
			 * 		int b=i;
			 * 		b=100; 		
			*/
			
			}
}
